Review slides, notes, and workshop materials. This is a comprehensive exam over the entire semester. Exam will be closed book. However, as a good study practice, it is suggested you prepare a one page summary of key definitions and terms in order to help you learn and practice the material.

High-level objections:

* Programmatically provision images.
* Automatically apply configuration management to production environments.
* Automatically create and maintain build environments.
* Maintain test suites and measure testing quality and coverage.
* Automatically generate new tests, using feedback-directed random testing, fuzzing, and data-flow analysis.
* Programmatically measure code quality via static and dynamic code analysis.
* Understand components of infrastructure.
* Remotely regulate behavior of deployed software via feature flags and configuration servers.
* Apply advanced strategies for deployment of software.
* Monitor and analyze telemetry data.
* Implement resilience testing on production environments (e.g., Chaos Monkey).


### Configuration Management/Core Concepts/Build

* Understand core concepts related to Configuration Management
* Identity traditional and modern components and practices related to configuration management
* Explain issues related to (not using configuration management)
* Design and apply configuration management concepts to a project.
* Explain differences between continuous integration, deployment, and delivery
* Explain operations responsibility models and team values
* 10 Adages Paper
* Explain concepts related to vagrant, and ansible
* Describe principles, benefits, and issues related to adopting continuous integration
* Design a build server

### Testing

* List and define different types of testing (e.g. acceptance testing vs integration testing)
* Compare and contrast testing methods
* Explain flaky tests, test priorization, and test management concepts.
* Explain automated test generation 
* Calculate basic constraints for test generation
* Compare different fuzzing techniques.
* List ways to seed fuzzing.
* Explain Benefits and problems of fuzzing.
* Understand alternative testing techninques such as natural language techniques.

### Analysis

* Understand metrics, including complexity, OO, and other techniques.
* Understand and derive program graph from code snippet.
* Define line, branch, condition, coverage.
* Explain subsumption and why and when one type of coverage may subsume another.
* Calculate line, branch, condition coverage.
* Identify other kinds of coverage: path coverage, mutation testing, data-flow coverage.
* Identify several uses cases for static analysis.
* Explain issues and benefits related to static analysis (e.g. versus dynamic analysis or verification.).
* Implement static analysis for measuring errors or code quality measures.


### Deployment/Infrastructure

* Identity Deployment Strategies
* Compare and contrast deployment strategies (issues/benefits)
* Feature Flags
* Understand staging and feature branch deployment
* Understand how to use docker for deployment and infrastructure design
* Identity components of cloud infrastructure
* Explain underlying issues related to infrastructure components
* Understand microservices
* Implement basic redis commands
* Design and apply infrastructure concepts for the design of a scalable and resilence application.
* Describe how to implement a deployment strategy

### Analysis + Monitoring

* Understand monitoring concepts and metrics
* Understand resilience testing, failure injection, and chaos engineering
* Implementing a flame graph representation from data
* Describing how to implement basic monkey concepts
* Design a monitoring and analysis system
